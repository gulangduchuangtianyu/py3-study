
文章标题： MySQL数据 汇总和分组查询总结
文章内容：一 汇总和分组数据SELECT 语句的执行顺序from 子句指定数据源where 子句基于指定的条件对记录进行筛选group by 子句将数据划分为多个分组使用聚合函数进行计算使用having子句筛选分组使用order by 子句对结果集进行排序查询语句 ---> 结果集（多条数据） ---> 聚合函数  ----> 单行记录1.常用的聚合函数：sum()         数字                          对指定列中的所有非空值求总和avg()          数字                          对指定列中的所有非空值求平均值min()    数字，字符，datetime        返回指定列中的最小数字，最早的日期或者最小的字符串max()   数字，字符，datetime        返回指定列中的最大数字，最近的日期或者最大的字符集count()   任意基于行的数据类型       统计结果集合众全部记录行的数量例：查询玩家表中一共有多少名玩家信息select count (user_qq) from users或select count(*) from users例：查询QQ号是12301的玩家游戏的总分数select sum(score) as '总分数' from scores where user_qq='12301'例：查询QQ号是12302玩家的评价分数select avg(score) as '平均分数’ from scores where user_qq='12302'例：查询游戏编号的1的最高分数select max(score) as '最高分数' from score where gno=1例： 查询QQ号是12302的玩家的总分数，平均分数和最高分数select sum(score) as '总分',avg(score) as '平均分',max(score) as '最高分' from scores where user_qq ='12302'2. 使用GROUP BY分组例：查询每个玩家的总分数，平均分数，最高分数select sum(score) as '总分',avg(score) as '平均分',max(score) as '最高分' from scores group by user_qq例： 查询每个玩家的平均分数，并显示玩家QQ号和平均分数select user_qq, avg(score) as '平均分数' from scores group by user_qq3. 筛选分组结果  在使用GROUP BY子句时，可用HAVING子句为分组统计进一步设置统计条件，HAVING子句与GROUP BY 子句的关系相当于WHERE子句与SELECT子句之间的关系 与WHERE子句的区别是，在HAVING子句中是以聚合函数的统计结果为筛选条件。 例：查询平均分数大于4000的玩家QQ号，总分数，平均分数select user_qq, sum(score) as'总分数', avg(score) as '平均分数' from scores group by user_qq having avg(score) > 4000例：查询所有用户的平均分数，和总分数，并按平均分数倒序排列select user_qq,avg(score) as '平均分数' , sun(score) as '总分数' from scores group by user_qq orde by avg(score) desc二 连接查询1. 多表连接例：查询分数信息，显示玩家昵称，游戏名称和分数select user_name as '昵称', game as '游戏名称' , score as '分数' from users.user_qq = scores.user_qq and game.gno= scores.gno连接查询分为内连接和外连接两种内连接特点：相连接的两张表地位平等                 如果一张表中在另一张表中不存在对应数据，则不做连接                 from 子句后面直接出现多个表名，这种连接方式即属于内连接，是隐式内连接                 显示内连接格式：select col_list from table1[inner] join table2 on table1.col=table2.clo1                 例：查询分数信息，显示玩家昵称，游戏名称和分数                 select user_name as '昵称', g_name as '游戏名称', score as '分数' from games inner join scores on games.gno =scores.gno                 inner join users on score.user_qq=user.user_qq                 例：查询每个玩家的昵称，总分和平均分                    select user_name as '昵称',sum(score) as '总分',avg(score) as '平均分' from users U inner join scores S on S.user_qq = U.user_qq group by                         U.user_qq,user_name                 例：查询平均分数大于3500的分数信息，显示玩家昵称，总分数，平均分数，并按照平均分数降序排列                  select user_name as '昵称',sum(score) as '总分',avg(score) as '平均分' from users U inner join scores S on S.user_qq = U.user_qq group by                         U.user_qq,user_name having avg(score)>3500 order by avg(score) desc外连接分为左连接和右外连接外连接特点：做连接的两个表地位不平等，其中有一张的基础表                 基础表中的每条数据必须出现，即使另一张表中没有数据与之匹配，也要用NULL补齐                 左外连接时左表是基础表，右表外连接时右表是基础表                 语句中先出现的表为'左表', 后出现的表为'右表'外连接格式： SELECT COL_LIST FROM TABLE1 LEFT/RIGHT[OUTER] JOIN TABLE2 ON TABLE1.COL=TABLE2.COL 例：查询所有玩家关于5号游戏的分数信息   select user_name as'昵称' gno as '游戏编号', score as '分数' from users U left join scores S on U.user_qq=S.user_qq and S.gno=5

文章标题：PHP定时器实现实现消息队列
文章内容：
php是服务器端脚本了并不像js那样有专业的settimeout函数来定时执行了，但只要浏览器不关闭各阶层是可以做到了，下面一起来看看。下面写个简单例子来讲解这个方法。<?php ignore_user_abort();//关闭浏览器仍然执行set_time_limit(0);//让程序一直执行下去$interval=3;//每隔一定时间运行do{    $msg=date("Y-m-d H:i:s");    file_put_contents("log.log",$msg,FILE_APPEND);//记录日志    sleep($interval);//等待时间，进行下一次操作。}while(true);?>需要说明的是：程序没有写结束判断语句，他会无限循环下去。当然如果想停止的话，可以重启apache，重启后就无效了。想再次进行定时执行，那么把这段代码再一次运行。上面简单例子可以说明这个原理。那么针对上面的例子，我可以进行一下改良方案。你需要一个执行脚本的开关，你可以用外部文件引入的方法来实现，在while循环的时候，include开关变量即可。那么就可以这样实现：建立外部引入变量文件 switch.php 内容如下：<?phpreturn 1;//1执行脚本 0退出执行脚本?>改良脚本如下：<?php    ignore_user_abort();//关闭浏览器后，继续执行php代码    set_time_limit(0);//程序执行时间无限制    $sleep_time = 5;//多长时间执行一次    $switch = include 'switch.php';    while($switch){        $switch = include 'switch.php';        $msg=date("Y-m-d H:i:s").$switch;            file_put_contents("log.log",$msg,FILE_APPEND);//记录日志        sleep($sleep_time);//等待时间，进行下一次操作。    }    exit(); ?>【上面这种方式，稳定性不好，执行脚本会由于一些不确定性的终止】当然我们也可以使用系统的定时执行php脚本了，下面看个linux的例子。在Crontab中使用PHP执行脚本就像在Crontab中调用普通的shell脚本一样（具体Crontab用法），使用PHP程序来调用PHP脚本。 每一小时执行myscript.php如下：# crontab -e 00 * * * * /usr/local/bin/php /home/john/myscript.php/usr/local/bin/php为PHP程序的路径。

文章标题：什么是程序的原子性
文章内容：程序的原子性指：整个程序中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。原子性操作：原子性在一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。即使在多个线程一起执行的时候，也是一个线程一个线程的依次执行操作，不会被其它线程所干扰。扩展资料：redis的原子性：Redis所有单个命令的执行都是原子性的，这与它的单线程机制有关；Redis命令的原子性使得我们不用考虑并发问题，可以方便的利用原子性自增操作 实现简单计数器功能;

文章标题：redis实现高并发下的抢购/秒杀功能
文章内容：
抢购/秒杀是如今很常见的一个应用场景，那么高并发竞争下如何解决超抢(或超卖库存不足为负数的问题)呢？常规写法：查询出对应商品的库存，看是否大于0，然后执行生成订单等操作，但是在判断库存是否大于0处，如果在高并发下就会有问题，导致库存量出现负数，所以在高并发下只使用mysql来做处理的话，是无法保证商品不会出现超卖的。这里我就只谈redis的解决方案吧...我们先来看以下代码（这里我以laravel为例吧）是否能正确解决超抢/卖的问题：<?php $num = 10;   //系统库存量 $user_id =  \Session::get('user_id');//当前抢购用户id $len = \Redis::llen('order:1');  //检查库存，order:1 定义为健名 if($len >= $num) 　　return '已经抢光了哦';$result = \Redis::lpush('order:1',$user_id);  //把抢到的用户存入到列表中if($result)　　return '恭喜您!抢到了哦';如果代码正常运行，按照预期理解的是列表order:1中最多只能存储10个用户的id，因为库存只有10个。然而，但是,在使用jmeter工具模拟多用户并发请求时，最后发现order:1中总是超过5个用户，也就是出现了“超抢/超卖”。分析问题就出在这一段代码： $len = \Redis::llen('order:1');  //检查库存，order:1 定义为健名 if($len >= $num) 　　return '已经抢光了哦';在抢购进行到一定程度，假如现在已经有9个人抢购成功，又来了3个用户同时抢购，这时if条件将会被绕过(llen命令并不是原子性操作，也就是说多个用户可以同时查询到同样的结果，条件同时被满足了),这三个用户都能抢购成功。而实际上只剩下一件库存可以抢了。在高并发下，很多看似不大可能是问题的，都成了实际产生的问题了。要解决“超抢/超卖”的问题，核心在于保证检查库存时的操作是依次执行的，再形象的说就是把“多线程”转成“单线程”。即使有很多用户同时到达，也是一个个检查并给与抢购资格，一旦库存抢尽，后面的用户就无法继续了。我们需要使用redis的原子操作来实现这个“单线程”。首先我们把库存存在goods_store:1这个列表中，假设有10件库存，就往列表中push10个1进去，当然这个1并没有实际意义，仅仅只是代表一件库存。抢购开始后，每到来一个用户，就从goods_store:1中pop一个数，表示用户抢购成功。当列表为空时，表示已经被抢光了。因为列表的pop操作是原子的，即使有很多用户同时到达，也是依次执行的。抢购的示例代码如下：比如这里我先把库存(可用库存,这里我强调下,一般都是商品详情页抢购,后来者进来看到的库存可能不再是后台系统配置的10个库存数了)放入redis队列： $num=10; //库存 for($i=0;$i<$num;$i++) 　　\Redis::lpush('goods_store',1);//往goods_store列表中,未抢购之前这里应该是默认滴push10个库存数了上面代码可以在抢购之前把库存先入队列。抢购时间到了：（大量用户进入请求下面代码，）/* 模拟抢购操作,抢购前判断redis队列库存量 */ $count=\Redis::lpop('goods_store:1');//lpop是移除并返回列表的第一个元素。 if(!$count)    return '已经抢光了哦'; /* 下面处理抢购成功流程 */\DB::table('goods')->decrement('num', 1);//减少num库存字段，同时在订单表里生成订单数据为了检测实际效果，我使用jmeter工具模拟100、200、1000个用户并发进行抢购，经过大量的测试，最终抢购成功的用户始终为10，没有出现“超抢/超卖”。 
文章标题：redis如何解决缓存雪崩？
文章内容：  为什么要用缓存(Redis)：现在有个问题，如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了。我们都知道Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。这就是缓存雪崩：1.Redis挂掉了，请求全部走数据库。2.对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。缓存雪崩如果发生了，很可能就把我们的数据库搞垮，导致整个服务瘫痪！如何解决缓存雪崩？（1）、对于“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”这种情况，非常好解决：解决方法：在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。（2）、对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。原文地址：https://juejin.im/post/5c3c1df2e51d45207f54b189
